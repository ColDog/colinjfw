<!DOCTYPE html>
<title>Where is Serverless Going | colinjfw</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Serverless as an idea has an incredible amount of hype and a huge amount of tools around it right now. But where is serverless going? How will it evolve over...">
<meta name="author" content="Colin Walker">
<meta name="generator" content="Jekyll v3.8.5">
<link rel="canonical" href="https://www.colinjfw.com/serverless-experience/">
<link rel="stylesheet" href="/assets/css/index.css">
<link rel="stylesheet" href="/assets/css/classes.css">
<link rel="stylesheet" href="/assets/css/contrast.css">
<link rel="alternate" type="application/atom+xml" href="/feed.xml" title="colinjfw" />




<body class="light">

<header>
  <h1><a href="/">colinjfw</a></h1>
  
  <nav><a class="icon" href="mailto:me@colinjfw.com"><svg><use xlink:href="/assets/fontawesome/icons.svg#envelope"></use></svg></a><a class="icon" href="https://www.twitter.com/colinjfw"><svg><use xlink:href="/assets/fontawesome/icons.svg#twitter"></use></svg></a><a class="icon" href="https://github.com/colinjfw"><svg><use xlink:href="/assets/fontawesome/icons.svg#github"></use></svg></a><a class="icon" href="/reading"><svg><use xlink:href="/assets/fontawesome/icons.svg#book"></use></svg></a><a class="icon" href="feed.xml"><svg><use xlink:href="/assets/fontawesome/icons.svg#rss"></use></svg></a></nav>
</header>

<article>
  <header><h1><a href="/serverless-experience/">Where is Serverless Going</a></h1>
    <time datetime="2018-09-19T00:00:00+00:00">September 19, 2018</time>
  </header>
<p>Serverless as an idea has an incredible amount of hype and a huge amount of
tools around it right now. But where is serverless going? How will it evolve
over the next 5 to 10 years?</p>

<p>In a previous post, I discussed the value of serverless as more of an
application paradigm. Serverless is a way in which we write and deploy code, not
a platform or a specific provider. It’s not lambda, it could be achieved with
writing code for kubernetes and deployed using containers.</p>

<h2 id="patterns">Patterns</h2>

<p>I’ve thought about a few different patterns of evolution that I believe
serverless will experience. These are general and not tied to a specific
platform overall.</p>

<h3 id="1-event-driven-application-architectures-will-become-normal-and-easier">1. Event driven application architectures will become normal and easier</h3>

<p>Event driven application architectures are effective for developing generic and
composable applications. They fit well in distributed systems and with
serverless functions. These applications will have better tooling and more
support overall.</p>

<h3 id="2-function-composition-components-will-emerge">2. Function composition components will emerge</h3>

<p>With more applications rushing in the direction of serverless and functions
being developed, there is a missing middle section. I have a function that
reacts to events to perform some sort of action, imagine a translation function
that will translate values into another language. To use this function, my data
storage layer needs to emit an event so that I can modify the document to add my
new translations. Wiring this all up will require new configurations and
paradigms.</p>

<p>These may even be in the form of new languages. Right now this is done using
static configuration languages like yaml, but the
<a href="https://ballerina.io">ballerina</a> programming language is a very interesting 
example of what is to come.</p>

<h3 id="3-kubernetes-will-probably-stay-but-be-heavily-hidden">3. Kubernetes will probably stay but be heavily hidden</h3>

<p>Kubernetes is too complex for most developers. With the emergence of opinionated
event driven application architectures, developers will be insulated from the
complexity of all of the kubernetes yaml files. This is a good thing. Kubernetes
as a platform will likely drive most of the serverless frameworks that will
emerge but developers will work with more code and less config.</p>

<h3 id="4-lambda-will-lose-out-in-favour-of-fargate">4. Lambda will lose out in favour of fargate</h3>

<p>Lambda and fargate are two aws serverless compute solutions. One runs
containers and one runs code inside specified runtimes. The lambda based
solution is cost effective but limited, functions are required to run in under 3
minutes and are limited in terms of CPU and memory. These types of runtimes will
begin to merge over time. A solution like fargate which runs a generic
application package will begin to become cheaper over time as platforms begin to
run more generic compute platforms.</p>

<h3 id="5-shipping-an-application-will-look-more-like-wiring-up-functions">5. Shipping an application will look more like wiring up functions</h3>

<p>Shipping a new application that performs common CRUD operations on a set of
resources will look more like wiring up a set of functions. Developers will be
able to deploy their favourite “Auth” function from a marketplace and wire this
up using gateways or workflow engines.</p>


  
  
</article>


<footer>
  <span></span>
  <a class="gray" href="/rds-operator/">Building an RDS Operator with the Operator Framework »</a>
</footer>




</body>
